var documenterSearchIndex = {"docs":
[{"location":"usage/#Usage-and-Examples","page":"Usage and Examples","title":"Usage and Examples","text":"","category":"section"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"This page shows the basic usage and features of the package, together with examples. You can also refer to the ./test/* directory.","category":"page"},{"location":"usage/#The-[NestedGraph](@ref)-struct","page":"Usage and Examples","title":"The NestedGraph struct","text":"","category":"section"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"This package defines the NestedGraph struct. Inside the struct, both the nested structure of the graphs is represented (in grv) and the flat graph (in flatgr). For communicating between grv and flatgr a mapping is defined in the vmap field. Lastly, all the top-level (nested) edges are stored in neds.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"For easier coding, we also define the struct NestedEdge and an alias type NestedVertex. NestedEdge connects 2 NestedVertexs. A tuple of Integer describes NestedVertex as: (domain_id, vertex_id), where vertex_id is the id of the vertex in the specific domain (or subgraph).","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"A NestedGraph is defined by 3 parameters {T,R,N}, where:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"T is the Integer type used in the graph.\nR is the type of graphs used. It shouldn't be a NestedGraph\nN is the type of the top-level nested graphs. It could be a NestedGraph","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"In simple scenarios (2-level nesting), R and N could be the same. More examples will be shared later.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Following, we deliberately define an abstract type NestedGraph, for more dynamicity.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> using NestedGraphs, Graphs; # initialize environment\n\njulia> DynNG = NestedGraph{Int, SimpleGraph{Int}, AbstractGraph}; # define the abstract type we will be working with\n\njulia> ng = DynNG()\nNestedGraph{SimpleGraph{Int64},AbstractGraph}({0,0}, 0 domains)","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Now we can directly start adding nodes or graphs in ng.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> add_vertex!(ng, SimpleGraph(3)); # add one graph\n\njulia> add_vertex!(ng, SimpleGraph(6)); # add another graph\n\njulia> ng\nNestedGraph{SimpleGraph{Int64},AbstractGraph}({9,0}, 2 domains)","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Now, ng has 2 subgraphs and overall 9 nodes. We can make the scenario more complicated and also add another nested graph.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> add_vertex!(ng, DynNG());\n\njulia> ng.grv\n3-element Vector{AbstractGraph}:\n {3, 0} undirected simple Int64 graph\n {6, 0} undirected simple Int64 graph\n NestedGraph{SimpleGraph{Int64},AbstractGraph}({0,0}, 0 domains)","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"We can see the three subgraphs stored inside ng. Now we can start adding end nodes to each domain.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> add_vertex!(ng; domains=1);\n\njulia> add_vertex!(ng; domains=2);\n\njulia> add_vertex!(ng; domains=3);\n\njulia> ng.grv\n3-element Vector{AbstractGraph}:\n {4, 0} undirected simple Int64 graph\n {7, 0} undirected simple Int64 graph\n NestedGraph{SimpleGraph{Int64},AbstractGraph}({1,0}, 1 domains)","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Now all subgraphs have one more node. But the third subgraph didn't have any nested domains. So, where did that node go? Let's see...","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> ng.grv[3].grv\n1-element Vector{AbstractGraph}:\n {1, 0} undirected simple Int64 graph","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"When the domains keyword is not given, a default of domains=1 is assumed. Also, if there is no subgraph at all, a new one is created. This is done so that there is always a consistent mapping between the flat graph flatgr and the nested graphs grv.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"We can continue adding nodes/subgraphs. For example let's add another graph of 2 nodes inside the nested NestedGraph with index 3.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> add_vertex!(ng, SimpleGraph(2); domains=3);\n\njulia> ng.grv[3].grv\n2-element Vector{AbstractGraph}:\n {1, 0} undirected simple Int64 graph\n {2, 0} undirected simple Int64 graph","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"And now, let's assume we would like to add a vertex in the 2nd subgraph of the third subgraph (i.e. on ng.grv[3].grv[2]). Then we would have to do","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> add_vertex!(ng, domains=[3,2]);\n\njulia> ng.grv[3].grv\n2-element Vector{AbstractGraph}:\n {1, 0} undirected simple Int64 graph\n {3, 0} undirected simple Int64 graph","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Success!","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"warning: Warning\nTo add/delete nodes/edges/graphs you always need to use as an argument the outmost NestedGraph. You can see an example how the following code will be faulty and bring the NestedGraph in an inconsistent state:julia> using Test;\n\njulia> sgs = [SimpleGraph(3), SimpleGraph(3)];\n\njulia> ng2 = NestedGraph(sgs)\nNestedGraph{SimpleGraph{Int64},SimpleGraph{Int64}}({6,0}, 2 domains)\n\njulia> add_vertex!(ng2, domains=1) # that's how you should add/remove nodes/edges/graphs\ntrue\n\njulia> @test nv(ng2) == nv(ng2.grv[1]) + nv(ng2.grv[2])\nTest Passed\n\njulia> add_vertex!(sgs[1])  # this is how you shouldn't do it. Don't access directly the subgraphs.\ntrue\n\njulia> @test nv(ng2) == nv(ng2.grv[1]) + nv(ng2.grv[2])\nTest Failed at none:1\n  Expression: nv(ng2) == nv(ng2.grv[1]) + nv(ng2.grv[2])\n   Evaluated: 7 == 8\nERROR: There was an error during testing","category":"page"},{"location":"usage/#Removing-nodes","page":"Usage and Examples","title":"Removing nodes","text":"","category":"section"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"We can remove nodes with the rem_vertex! function.  Assume we would like to remove the node we previously added, i.e. the 3rd node of the 2nd nested graph of the 3rd top-level nested graph.   So, the \"path\" to this node is [3,2,3] where the last element is the node id and all previous are the domain id's to follow.  To remove that index we do:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> v323 = roll_vertex(ng, [3,2,3]) # get top-level representation in the flatgraph of the NestedVertex\n15\n\njulia> rem_vertex!(ng, v323);\n\njulia> ng.grv[3].grv # see that index is deleted\n2-element Vector{AbstractGraph}:\n {1, 0} undirected simple Int64 graph\n {2, 0} undirected simple Int64 graph\n","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"For now removing works only for nodes and not for graphs. Support of removing graphs is on the way (not particularly hard to implement).","category":"page"},{"location":"usage/#Handling-Edges","page":"Usage and Examples","title":"Handling Edges","text":"","category":"section"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Similarly we can use the add_edge! and rem_edge!. For example to add an edge between the node 3 and node 8 of the flatgr you do:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> add_edge!(ng, 3, 8);\n\njulia> ng\nNestedGraph{SimpleGraph{Int64},AbstractGraph}({14,1}, 3 domains)","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"{14,1} specifies that the NestedGraph has 14 nodes and 1 edge, which we just added. You can again follow the previous style of calling roll_vertex to identify nodes.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"In the previous case the edge doesn't propagate to the the nested domains because it connects top-level domains. For this reason you can find it in the neds field","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> ng.neds\n1-element Vector{NestedEdge{Int64}}:\n Edge (1, 3) => (2, 5)","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Also see that the nested domains still don't have any edge:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> ng.grv\n3-element Vector{AbstractGraph}:\n {4, 0} undirected simple Int64 graph\n {7, 0} undirected simple Int64 graph\n NestedGraph{SimpleGraph{Int64},AbstractGraph}({3,0}, 2 domains)","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"On the contrary doing the following will propage the edge all the way to the 2nd subgraph of the 3rd subgraph.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> add_edge!(ng, roll_vertex(ng, [3,2,1]), roll_vertex(ng, [3,2,2]));\n\njulia> @test ne(ng.grv[3]) == ne(ng.grv[3].grv[2]) == 1\nTest Passed","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"note: Note\nOf course, instead of adding edges from zero, you can directly add graphs that containt edges.julia> cgs = [complete_graph(3), complete_graph(3)];\n\njulia> ng3 = NestedGraph(cgs)\nNestedGraph{SimpleGraph{Int64},SimpleGraph{Int64}}({6,6}, 2 domains)You can also initialize the NestedGraph with some edges between the nested graphs. For example initialize with 2 NestedEdge. That is a NestedEdge between the 2nd node of the 1st graph and the 3rd node of the 2nd graph and another one between the 1st node of the 1st graph and the 1 node of the 2nd graph.julia> ng4 = NestedGraph(cgs, [((1,2), (2,3)), ((1,1), (2,1))])\nNestedGraph{SimpleGraph{Int64},SimpleGraph{Int64}}({6,8}, 2 domains)","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"info: Info\nWe are aware that handling nested graphs can be complicated and at this moment the syntax to do so could be more friendly. Future work will focus on syntantic sugar.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"info: Info\nMost of the times illustrating a nested graph can be very helpful. There is currently Work In Progress for a NestedGraphMakie package.","category":"page"},{"location":"usage/#Understanding-the-mapping-from-flat-graph-to-nested-graphs","page":"Usage and Examples","title":"Understanding the mapping from flat graph to nested graphs","text":"","category":"section"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"The NestedGraph ng contains nv(ng) = 14 vertices. The vmap field will show us to which subgraphs they belong.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> ng.vmap |> pairs\npairs(::Vector{Tuple{Int64, Int64}})(...):\n  1  => (1, 1)\n  2  => (1, 2)\n  3  => (1, 3)\n  4  => (2, 1)\n  5  => (2, 2)\n  6  => (2, 3)\n  7  => (2, 4)\n  8  => (2, 5)\n  9  => (2, 6)\n  10 => (1, 4)\n  11 => (2, 7)\n  12 => (3, 1)\n  13 => (3, 2)\n  14 => (3, 3)","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"For example node 14 of the flatgr refers to the 3rd node of the 3rd subgraph. If we again ask vmap what exactly this node is we get:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> ng.grv[3].vmap |> pairs\npairs(::Vector{Tuple{Int64, Int64}})(...):\n  1 => (1, 1)\n  2 => (2, 1)\n  3 => (2, 2)","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"This means the 3rd node of the 3rd subgraph refers locally to the 2nd node of the 2nd subgraph. Since this 2nd subgraph is not a NestedGraph we are sure that the chain ends here:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> ng.grv[3].grv[2] |> typeof\nSimpleGraph{Int64}","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"So overall the 14th node of ng is referring to the 2nd node of the 2nd subgraph of the 3rd subgraph. This can be retrieved directly will the unroll_vertex:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> unroll_vertex(ng, 14)\n3-element Vector{Int64}:\n 3\n 2\n 2","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"As we saw previously the roll_vertex does exactly the opposite:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> roll_vertex(ng, unroll_vertex(ng, 14)) == 14\ntrue","category":"page"},{"location":"usage/#Type-stable-NestedGraph","page":"Usage and Examples","title":"Type stable NestedGraph","text":"","category":"section"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"The same procedure follows with the definition of a non abstract typed NestedGraph.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> ng5 = NestedGraph([SimpleGraph(3), SimpleGraph(3)])\nNestedGraph{SimpleGraph{Int64},SimpleGraph{Int64}}({6,0}, 2 domains)\n\njulia> ng5 |> typeof # NestedGraph instance is type stable now\nNestedGraph{Int64, SimpleGraph{Int64}, SimpleGraph{Int64}}","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Of course, we are more constrained with types now:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> @test_throws MethodError add_vertex!(ng2, DynNG())\nTest Passed\n      Thrown: MethodError","category":"page"},{"location":"usage/#MetaGraphs-support","page":"Usage and Examples","title":"MetaGraphs support","text":"","category":"section"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"NestedGraphs.jl comes with built-in support for MetaGraphs. Dealing with generic data in nested structures augments the problem of synchronization. This problem has already been solved for adding/deleting graphs/nodes/edges as shown previously. However these elements didn't contain any data. Previously with SimpleGraphs, you couldn't really tell apart 2 nodes and deleting one or the other would many times be indistinguishable (given that edges don't reveal a pattern). But now, each node can carry different data making it identifiable. Moreover we would like to be able to modify the data of a node and automatically propagate the changes to the nested graphs.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"To deal with the problem of synchronization Julia offers several tools for reactive programming. However, at the moment we deal with this problem with shallow copying of the data. This makes the overall update mechanism much simpler, faster and more reliable.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"The interface to NestedGraphs stays the same:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> using MetaGraphs;\n\njulia> mgs = [MetaGraph(3), MetaGraph(3)];\n\njulia> nmg = NestedGraph(mgs)\nNestedGraph{MetaGraph{Int64, Float64},MetaGraph{Int64, Float64}}({6,0}, 2 domains)","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Now we can add some data to the Nested(Meta)Graph:","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> set_prop!(nmg, 2, :el, \"elelemt_data\") # add data to the 2nd node of nmg\ntrue","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"Finally notice that the data for the flatgr and the node inside grv are identical, meaning that they reference to the same part in memory.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"julia> props(nmg.flatgr, 2) === props(nmg.grv[nmg.vmap[2][1]], nmg.vmap[2][2])\ntrue","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"As a result, updates to the modified data are done instantly.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"The same holds for deeper nested graphs and for edge data.","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"info: Info\nThere are many resources online for the difference between == and === in Julia. ","category":"page"},{"location":"usage/","page":"Usage and Examples","title":"Usage and Examples","text":"info: Info\nNestedGraphs.jl boils down to just being a wrapper. This means more graph types can be supported. In the future we will disintegrate MetaGraphs from the NestedGraphs.jl to possibly an external package (or we might use Require.jl) in order to not always carry this dependency to the end users. In the future we would also like to support a type-stable version of MetaGraphs, the MetaGraphsNext.jl.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A package to handle nested graphs.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"NestedGraphs.jl is a young project that aims at easy and type-stable graph analysis for nested graphs. This package is in an early development stage and might break often. For a walkthrough of the features, see the Usage and Examples page.","category":"page"},{"location":"#Concept","page":"Introduction","title":"Concept","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The main concept is to hold all nested graphs in a Vector and synchronize them with a flat graph. This means that for each AbstractGraph double the space is allocated. The stored flat graph can be used to call all available functions from the Graphs.jl ecosystem.","category":"page"},{"location":"#Roadmap","page":"Introduction","title":"Roadmap","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"more support for interfaces of Graphs.jl and MetaGraphs (WIP)\nMakie recipes based on GraphMakie.jl (WIP)\nreading/writing NestedGraphs with GraphIO.jl (WIP)\nsupport for MetaGraphsNext.jl\nsyntactic sugar","category":"page"},{"location":"#Contribution","page":"Introduction","title":"Contribution","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Contributors are welcome. For any ideas or bug reports, feel free to open an issue.","category":"page"},{"location":"#Motivation","page":"Introduction","title":"Motivation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"NestedGraphs.jl has been created for the analysis of multi-domain networks.","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [NestedGraphs]\nPrivate = false\nOrder   = [:function, :type]","category":"page"},{"location":"API/#NestedGraphs.domain-Union{Tuple{T}, Tuple{NestedGraph, T}} where T<:Integer","page":"API","title":"NestedGraphs.domain","text":"Get the domain index of a vertex v\n\n\n\n\n\n","category":"method"},{"location":"API/#NestedGraphs.domainedge-Tuple{NestedGraph, Graphs.SimpleGraphs.SimpleEdge}","page":"API","title":"NestedGraphs.domainedge","text":"domainedge(\n    ng::NestedGraph,\n    e::Graphs.SimpleGraphs.SimpleEdge\n) -> Union{Nothing, Graphs.SimpleGraphs.SimpleEdge}\n\n\nGet the domain of an edge If the edge connects 2 domains, it returns nothing\n\n\n\n\n\n","category":"method"},{"location":"API/#NestedGraphs.edge-Tuple{NestedGraph, NestedEdge}","page":"API","title":"NestedGraphs.edge","text":"edge(\n    ng::NestedGraph,\n    ce::NestedEdge\n) -> Graphs.SimpleGraphs.SimpleEdge{Int64}\n\n\nConvert a local view NestedEdge to a global view\n\n\n\n\n\n","category":"method"},{"location":"API/#NestedGraphs.interdomainedges-Tuple{NestedGraph}","page":"API","title":"NestedGraphs.interdomainedges","text":"interdomainedges(ng::NestedGraph) -> Any\n\n\nGet all edges that have no domain, i.e. that interconnect domains\n\n\n\n\n\n","category":"method"},{"location":"API/#NestedGraphs.nestededge-Tuple{NestedGraph, Graphs.SimpleGraphs.SimpleEdge}","page":"API","title":"NestedGraphs.nestededge","text":"nestededge(\n    ng::NestedGraph,\n    e::Graphs.SimpleGraphs.SimpleEdge\n) -> NestedEdge\n\n\nConvert a global view of an edge to local view NestedEdge\n\n\n\n\n\n","category":"method"},{"location":"API/#NestedGraphs.nestedvertex-Tuple{NestedGraph, Any}","page":"API","title":"NestedGraphs.nestedvertex","text":"nestedvertex(ng::NestedGraph, v) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/#NestedGraphs.roll_vertex-Union{Tuple{T}, Tuple{NestedGraph, AbstractVector{T}}} where T<:Integer","page":"API","title":"NestedGraphs.roll_vertex","text":"roll_vertex(\n    ng::NestedGraph,\n    v::AbstractArray{T<:Integer, 1}\n) -> Union{Nothing, Int64}\n\n\nGiven a vector of the nested inner domains get the index in the flat graph. The last element of the vector is handled as the node number in the v[1:end-1] inner nested graph\n\n\n\n\n\n","category":"method"},{"location":"API/#NestedGraphs.unroll_vertex-Union{Tuple{T}, Tuple{NestedGraph, T}} where T<:Integer","page":"API","title":"NestedGraphs.unroll_vertex","text":"unroll_vertex(ng::NestedGraph, v::Integer) -> Vector\n\n\nUnroll a nested vertex along all the nested graph domains\n\n\n\n\n\n","category":"method"},{"location":"API/#NestedGraphs.vertex-Tuple{NestedGraph, Tuple{T, T} where T<:Integer}","page":"API","title":"NestedGraphs.vertex","text":"vertex(\n    ng::NestedGraph,\n    cv::Tuple{T, T} where T<:Integer\n) -> Union{Nothing, Int64}\n\n\nConvert a local view NestedVertex to a global view\n\n\n\n\n\n","category":"method"},{"location":"API/#NestedGraphs.vertex-Union{Tuple{T}, Tuple{NestedGraph, T, T}} where T<:Integer","page":"API","title":"NestedGraphs.vertex","text":"vertex(\n    ng::NestedGraph,\n    d::Integer,\n    v::Integer\n) -> Union{Nothing, Int64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/#NestedGraphs.NestedEdge","page":"API","title":"NestedGraphs.NestedEdge","text":"struct NestedEdge{T<:Integer} <: Graphs.SimpleGraphs.AbstractSimpleEdge{T<:Integer}\n\nsrc::Tuple{T, T} where T<:Integer\ndst::Tuple{T, T} where T<:Integer\n\nA NestedEdge connects graphs inside a NestedGraph or simply nodes inside a NestedGraph. The NestedEdge connects two NestedVertexs. This means that every NestedEdge connects to a specific node and not as a hyperedge to the whole domain graph.\n\n\n\n\n\n","category":"type"},{"location":"API/#NestedGraphs.NestedGraph","page":"API","title":"NestedGraphs.NestedGraph","text":"struct NestedGraph{T<:Integer, R<:AbstractGraph{T<:Integer}, N<:AbstractGraph} <: AbstractGraph{T<:Integer}\n\nflatgr::AbstractGraph{T} where T<:Integer\n\n: Flat graph view combining all domain graphs given with the edges\n\ngrv::Vector{N} where N<:AbstractGraph\n\n: Original domain graphs\n\nneds::Array{NestedEdge{T}, 1} where T<:Integer\n\n: interdomain edges\n\nvmap::Array{Tuple{T, T}, 1} where T<:Integer\n\n: Maps the nodes of flat network to the original graph (Domain, Node)\n\nA NestedGraph is a graph of vertices, where each vertex can be a complete graph. Connections are done with NestedEdges and the vertices are NestedVertexs. NestedGraphs of NestedGraphs are allowed.\n\n\n\n\n\n","category":"type"},{"location":"API/#NestedGraphs.NestedVertex","page":"API","title":"NestedGraphs.NestedVertex","text":"struct Tuple{T<:Integer, T<:Integer}\n\nA NestedVertex is the local view of a vertex inside a NestedGraph. It contains the domain and the vertex indices. Basically, it's an alias for a 2-element Tuple.\n\n\n\n\n\n","category":"type"},{"location":"API/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"","category":"page"}]
}
