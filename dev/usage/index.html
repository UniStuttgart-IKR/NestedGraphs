<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Usage and Examples · NestedGraphs.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="NestedGraphs.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">NestedGraphs.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Usage and Examples</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#The-[NestedGraph](@ref)-struct"><span>The <code>NestedGraph</code> struct</span></a></li><li class="toplevel"><a class="tocitem" href="#Removing-nodes"><span>Removing nodes</span></a></li><li class="toplevel"><a class="tocitem" href="#Handling-Edges"><span>Handling Edges</span></a></li><li class="toplevel"><a class="tocitem" href="#Understanding-the-mapping-from-flat-graph-to-nested-graphs"><span>Understanding the mapping from flat graph to nested graphs</span></a></li><li class="toplevel"><a class="tocitem" href="#Type-stable-NestedGraph"><span>Type stable <code>NestedGraph</code></span></a></li><li class="toplevel"><a class="tocitem" href="#MetaGraphs-support"><span>MetaGraphs support</span></a></li><li class="toplevel"><a class="tocitem" href="#A-use-case-with-multi-layer-graphs"><span>A use case with multi layer graphs</span></a></li></ul></li><li><a class="tocitem" href="../API/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Usage and Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Usage and Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/UniStuttgart-IKR/NestedGraphs.jl/blob/main/docs/src/usage.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Usage-and-Examples"><a class="docs-heading-anchor" href="#Usage-and-Examples">Usage and Examples</a><a id="Usage-and-Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Usage-and-Examples" title="Permalink"></a></h1><p>This page shows the basic usage and features of the package, together with examples. You can also refer to the <code>./test/*</code> directory.</p><h1 id="The-[NestedGraph](@ref)-struct"><a class="docs-heading-anchor" href="#The-[NestedGraph](@ref)-struct">The <a href="../API/#NestedGraphs.NestedGraph"><code>NestedGraph</code></a> struct</a><a id="The-[NestedGraph](@ref)-struct-1"></a><a class="docs-heading-anchor-permalink" href="#The-[NestedGraph](@ref)-struct" title="Permalink"></a></h1><p>This package defines the <a href="../API/#NestedGraphs.NestedGraph"><code>NestedGraph</code></a> struct. Inside the struct, both the nested structure of the graphs is represented (in <code>grv</code>) and the flat graph (in <code>flatgr</code>). For communicating between <code>grv</code> and <code>flatgr</code> a mapping is defined in the <code>vmap</code> field. Lastly, all the top-level (nested) edges are stored in <code>neds</code>.</p><p>For easier coding, we also define the struct <a href="../API/#NestedGraphs.NestedEdge"><code>NestedEdge</code></a> and an alias type <a href="../API/#NestedGraphs.NestedVertex"><code>NestedVertex</code></a>. <code>NestedEdge</code> connects 2 <code>NestedVertex</code>s. A tuple of <code>Integer</code> describes <code>NestedVertex</code> as: (<em>subgraph_id</em>, <em>vertex_id</em>), where <em>vertex_id</em> is the id of the vertex in the specific subgraph.</p><p>A <code>NestedGraph</code> is defined by 3 parameters <code>{T,R,N}</code>, where:</p><ul><li><code>T</code> is the <code>Integer</code> type used in the graph.</li><li><code>R</code> is the type of graphs used. It shouldn&#39;t be a <code>NestedGraph</code></li><li><code>N</code> is the type of the top-level nested graphs. It could be a <code>NestedGraph</code></li></ul><p>In simple scenarios (2-level nesting), <code>R</code> and <code>N</code> could be the same. More examples will be shared later.</p><p>Following, we deliberately define an abstract type <code>NestedGraph</code>, for more dynamicity.</p><pre><code class="language-julia-repl hljs">julia&gt; using NestedGraphs, Graphs; # initialize environment

julia&gt; DynNG = NestedGraph{Int, SimpleGraph{Int}, AbstractGraph}; # define the abstract type we will be working with

julia&gt; ng = DynNG()
NestedGraph{SimpleGraph{Int64},AbstractGraph}({0,0}, 0 subgraphs)</code></pre><p>Now we can directly start adding nodes or graphs in <code>ng</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; add_vertex!(ng, SimpleGraph(3)); # add one graph

julia&gt; add_vertex!(ng, SimpleGraph(6)); # add another graph

julia&gt; ng
NestedGraph{SimpleGraph{Int64},AbstractGraph}({9,0}, 2 subgraphs)</code></pre><p>Now, <code>ng</code> has 2 subgraphs and overall 9 nodes. We can make the scenario more complicated and also add another nested graph.</p><pre><code class="language-julia-repl hljs">julia&gt; add_vertex!(ng, DynNG());

julia&gt; ng.grv
3-element Vector{AbstractGraph}:
 {3, 0} undirected simple Int64 graph
 {6, 0} undirected simple Int64 graph
 NestedGraph{SimpleGraph{Int64},AbstractGraph}({0,0}, 0 subgraphs)</code></pre><p>We can see the three subgraphs stored inside <code>ng</code>. Now we can start adding end nodes to each subgraph.</p><pre><code class="language-julia-repl hljs">julia&gt; add_vertex!(ng; subgraphs=1);

julia&gt; add_vertex!(ng; subgraphs=2);

julia&gt; add_vertex!(ng; subgraphs=3);

julia&gt; ng.grv
3-element Vector{AbstractGraph}:
 {4, 0} undirected simple Int64 graph
 {7, 0} undirected simple Int64 graph
 NestedGraph{SimpleGraph{Int64},AbstractGraph}({1,0}, 1 subgraphs)</code></pre><p>Now all subgraphs have one more node. But the third subgraph didn&#39;t have any nested subgraphs. So, where did that node go? Let&#39;s see...</p><pre><code class="language-julia-repl hljs">julia&gt; ng.grv[3].grv
1-element Vector{AbstractGraph}:
 {1, 0} undirected simple Int64 graph</code></pre><p>When the <code>subgraphs</code> keyword is not given, a default of <code>subgraphs=1</code> is assumed. Also, if there is no subgraph at all, a new one is created. This is done so that there is always a consistent mapping between the flat graph <code>flatgr</code> and the nested graphs <code>grv</code>.</p><p>We can continue adding nodes/subgraphs. For example let&#39;s add another graph of 2 nodes inside the nested <code>NestedGraph</code> with index 3.</p><pre><code class="language-julia-repl hljs">julia&gt; add_vertex!(ng, SimpleGraph(2); subgraphs=3);

julia&gt; ng.grv[3].grv
2-element Vector{AbstractGraph}:
 {1, 0} undirected simple Int64 graph
 {2, 0} undirected simple Int64 graph</code></pre><p>And now, let&#39;s assume we would like to add a vertex in the 2nd subgraph of the third subgraph (i.e. on <code>ng.grv[3].grv[2]</code>). Then we would have to do</p><pre><code class="language-julia-repl hljs">julia&gt; add_vertex!(ng, subgraphs=[3,2]);

julia&gt; ng.grv[3].grv
2-element Vector{AbstractGraph}:
 {1, 0} undirected simple Int64 graph
 {3, 0} undirected simple Int64 graph</code></pre><p>Success!</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>To add/delete nodes/edges/graphs you always need to use as an argument the outmost <code>NestedGraph</code>. You can see an example how the following code will be faulty and bring the <code>NestedGraph</code> in an inconsistent state:</p><pre><code class="language-julia-repl hljs">julia&gt; using Test;

julia&gt; sgs = [SimpleGraph(3), SimpleGraph(3)];

julia&gt; ng2 = NestedGraph(sgs)
NestedGraph{SimpleGraph{Int64},SimpleGraph{Int64}}({6,0}, 2 subgraphs)

julia&gt; add_vertex!(ng2, subgraphs=1) # that&#39;s how you should add/remove nodes/edges/graphs
true

julia&gt; @test nv(ng2) == nv(ng2.grv[1]) + nv(ng2.grv[2])
Test Passed

julia&gt; add_vertex!(sgs[1])  # this is how you shouldn&#39;t do it. Don&#39;t access directly the subgraphs.
true

julia&gt; @test nv(ng2) == nv(ng2.grv[1]) + nv(ng2.grv[2])
Test Failed at none:1
  Expression: nv(ng2) == nv(ng2.grv[1]) + nv(ng2.grv[2])
   Evaluated: 7 == 8

ERROR: There was an error during testing</code></pre></div></div><h1 id="Removing-nodes"><a class="docs-heading-anchor" href="#Removing-nodes">Removing nodes</a><a id="Removing-nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Removing-nodes" title="Permalink"></a></h1><p>We can remove nodes with the <code>rem_vertex!</code> function.  Assume we would like to remove the node we previously added, i.e. the 3rd node of the 2nd nested graph of the 3rd top-level nested graph.   So, the &quot;path&quot; to this node is <code>[3,2,3]</code> where the last element is the node id and all previous are the subgraph id&#39;s to follow.  To remove that index we do:</p><pre><code class="language-julia-repl hljs">julia&gt; v323 = roll_vertex(ng, [3,2,3]) # get top-level representation in the flatgraph of the NestedVertex
15

julia&gt; rem_vertex!(ng, v323);

julia&gt; ng.grv[3].grv # see that index is deleted
2-element Vector{AbstractGraph}:
 {1, 0} undirected simple Int64 graph
 {2, 0} undirected simple Int64 graph
</code></pre><p>Similarly we can delete nodes directly by specifying the unrolled path to that node. For example the above block does equivalent job to this:</p><pre><code class="language-julia-repl hljs">julia&gt; add_vertex!(ng; subgraphs = [3,2]) # restore previously removed node
true

julia&gt; rem_vertex!(ng, [3,2,3]) # directly remove node</code></pre><p>If the specified path doesn&#39;t point to a node, but to a graph, this whole graph is deleted instead.</p><pre><code class="language-julia-repl hljs">julia&gt; add_vertex!(ng, SimpleGraph(10); subgraphs=[3]); # add a graph that we will delete later

julia&gt; ng.grv[3].grv
3-element Vector{AbstractGraph}:
 {1, 0} undirected simple Int64 graph
 {2, 0} undirected simple Int64 graph
 {10, 0} undirected simple Int64 graph

julia&gt; rem_vertex!(ng, [3,3]) # delete previously added graph

julia&gt; ng.grv[3].grv
2-element Vector{AbstractGraph}:
 {1, 0} undirected simple Int64 graph
 {2, 0} undirected simple Int64 graph
</code></pre><h1 id="Handling-Edges"><a class="docs-heading-anchor" href="#Handling-Edges">Handling Edges</a><a id="Handling-Edges-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-Edges" title="Permalink"></a></h1><p>Similarly we can use the <code>add_edge!</code> and <code>rem_edge!</code>. For example to add an edge between the node 3 and node 8 of the <code>flatgr</code> you do:</p><pre><code class="language-julia-repl hljs">julia&gt; add_edge!(ng, 3, 8);

julia&gt; ng
NestedGraph{SimpleGraph{Int64},AbstractGraph}({14,1}, 3 subgraphs)</code></pre><p><code>{14,1}</code> specifies that the <code>NestedGraph</code> has 14 nodes and 1 edge, which we just added. You can again follow the previous style of calling <code>roll_vertex</code> to identify nodes.</p><p>In the previous case the edge doesn&#39;t propagate to the the nested subgraphs because it connects top-level subgraphs. For this reason you can find it in the <code>neds</code> field</p><pre><code class="language-julia-repl hljs">julia&gt; ng.neds
1-element Vector{NestedEdge{Int64}}:
 Edge (1, 3) =&gt; (2, 5)</code></pre><p>Also see that the nested subgraphs still don&#39;t have any edge:</p><pre><code class="language-julia-repl hljs">julia&gt; ng.grv
3-element Vector{AbstractGraph}:
 {4, 0} undirected simple Int64 graph
 {7, 0} undirected simple Int64 graph
 NestedGraph{SimpleGraph{Int64},AbstractGraph}({3,0}, 2 subgraphs)</code></pre><p>On the contrary doing the following will propage the edge all the way to the 2nd subgraph of the 3rd subgraph.</p><pre><code class="language-julia-repl hljs">julia&gt; add_edge!(ng, roll_vertex(ng, [3,2,1]), roll_vertex(ng, [3,2,2]));

julia&gt; @test ne(ng.grv[3]) == ne(ng.grv[3].grv[2]) == 1
Test Passed</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Of course, instead of adding edges from zero, you can directly add graphs that containt edges.</p><pre><code class="language-julia-repl hljs">julia&gt; cgs = [complete_graph(3), complete_graph(3)];

julia&gt; ng3 = NestedGraph(cgs)
NestedGraph{SimpleGraph{Int64},SimpleGraph{Int64}}({6,6}, 2 subgraphs)</code></pre><p>You can also initialize the <code>NestedGraph</code> with some edges between the nested graphs. For example initialize with 2 <code>NestedEdge</code>. That is a <code>NestedEdge</code> between the 2nd node of the 1st graph and the 3rd node of the 2nd graph and another one between the 1st node of the 1st graph and the 1 node of the 2nd graph.</p><pre><code class="language-julia-repl hljs">julia&gt; ng4 = NestedGraph(cgs, [((1,2), (2,3)), ((1,1), (2,1))])
NestedGraph{SimpleGraph{Int64},SimpleGraph{Int64}}({6,8}, 2 subgraphs)</code></pre></div></div><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>We are aware that handling nested graphs can be complicated and at this moment the syntax to do so could be more friendly. Future work will focus on syntantic sugar.</p></div></div><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Most of the times illustrating a nested graph can be very helpful. There is currently <em>Work In Progress</em> for a <code>NestedGraphMakie</code> package.</p></div></div><h1 id="Understanding-the-mapping-from-flat-graph-to-nested-graphs"><a class="docs-heading-anchor" href="#Understanding-the-mapping-from-flat-graph-to-nested-graphs">Understanding the mapping from flat graph to nested graphs</a><a id="Understanding-the-mapping-from-flat-graph-to-nested-graphs-1"></a><a class="docs-heading-anchor-permalink" href="#Understanding-the-mapping-from-flat-graph-to-nested-graphs" title="Permalink"></a></h1><p>The <code>NestedGraph</code> <code>ng</code> contains <code>nv(ng) = 14</code> vertices. The <code>vmap</code> field will show us to which subgraphs they belong.</p><pre><code class="language-julia-repl hljs">julia&gt; ng.vmap |&gt; pairs
pairs(::Vector{Tuple{Int64, Int64}})(...):
  1  =&gt; (1, 1)
  2  =&gt; (1, 2)
  3  =&gt; (1, 3)
  4  =&gt; (2, 1)
  5  =&gt; (2, 2)
  6  =&gt; (2, 3)
  7  =&gt; (2, 4)
  8  =&gt; (2, 5)
  9  =&gt; (2, 6)
  10 =&gt; (1, 4)
  11 =&gt; (2, 7)
  12 =&gt; (3, 1)
  13 =&gt; (3, 2)
  14 =&gt; (3, 3)</code></pre><p>For example node 14 of the <code>flatgr</code> refers to the 3rd node of the 3rd subgraph. If we again ask <code>vmap</code> what exactly this node is we get:</p><pre><code class="language-julia-repl hljs">julia&gt; ng.grv[3].vmap |&gt; pairs
pairs(::Vector{Tuple{Int64, Int64}})(...):
  1 =&gt; (1, 1)
  2 =&gt; (2, 1)
  3 =&gt; (2, 2)</code></pre><p>This means the 3rd node of the 3rd subgraph refers locally to the 2nd node of the 2nd subgraph. Since this 2nd subgraph is not a <code>NestedGraph</code> we are sure that the chain ends here:</p><pre><code class="language-julia-repl hljs">julia&gt; ng.grv[3].grv[2] |&gt; typeof
SimpleGraph{Int64}</code></pre><p>So overall the 14th node of <code>ng</code> is referring to the 2nd node of the 2nd subgraph of the 3rd subgraph. This can be retrieved directly will the <code>unroll_vertex</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; unroll_vertex(ng, 14)
3-element Vector{Int64}:
 3
 2
 2</code></pre><p>As we saw previously the <code>roll_vertex</code> does exactly the opposite:</p><pre><code class="language-julia-repl hljs">julia&gt; roll_vertex(ng, unroll_vertex(ng, 14)) == 14
true</code></pre><h1 id="Type-stable-NestedGraph"><a class="docs-heading-anchor" href="#Type-stable-NestedGraph">Type stable <code>NestedGraph</code></a><a id="Type-stable-NestedGraph-1"></a><a class="docs-heading-anchor-permalink" href="#Type-stable-NestedGraph" title="Permalink"></a></h1><p>The same procedure follows with the definition of a non abstract typed <code>NestedGraph</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; ng5 = NestedGraph([SimpleGraph(3), SimpleGraph(3)])
NestedGraph{SimpleGraph{Int64},SimpleGraph{Int64}}({6,0}, 2 subgraphs)

julia&gt; ng5 |&gt; typeof # NestedGraph instance is type stable now
NestedGraph{Int64, SimpleGraph{Int64}, SimpleGraph{Int64}}</code></pre><p>Of course, we are more constrained with types now:</p><pre><code class="language-julia-repl hljs">julia&gt; @test_throws MethodError add_vertex!(ng2, DynNG())
Test Passed
      Thrown: MethodError</code></pre><h1 id="MetaGraphs-support"><a class="docs-heading-anchor" href="#MetaGraphs-support">MetaGraphs support</a><a id="MetaGraphs-support-1"></a><a class="docs-heading-anchor-permalink" href="#MetaGraphs-support" title="Permalink"></a></h1><p><code>NestedGraphs.jl</code> comes with built-in support for <a href="https://github.com/JuliaGraphs/MetaGraphs.jl"><code>MetaGraphs</code></a> using package extensions. Dealing with generic data in nested structures augments the problem of synchronization. This problem has already been solved for adding/deleting graphs/nodes/edges as shown previously. However these elements didn&#39;t contain any data. Previously with <code>SimpleGraphs</code>, you couldn&#39;t really tell apart 2 nodes and deleting one or the other would many times be indistinguishable (given that edges don&#39;t reveal a pattern). But now, each node can carry different data making it identifiable. Moreover we would like to be able to modify the data of a node and automatically propagate the changes to the nested graphs.</p><p>To deal with the problem of synchronization Julia offers several tools for reactive programming. However, at the moment we deal with this problem with shallow copying of the data. This makes the overall update mechanism much simpler, faster and more reliable.</p><p>The interface to <code>NestedGraphs</code> stays the same:</p><pre><code class="language-julia-repl hljs">julia&gt; using MetaGraphs;

julia&gt; mgs = [MetaGraph(3), MetaGraph(3)];

julia&gt; nmg = NestedGraph(mgs)
NestedGraph{MetaGraph{Int64, Float64},MetaGraph{Int64, Float64}}({6,0}, 2 subgraphs)</code></pre><p>Now we can add some data to the <code>Nested(Meta)Graph</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; set_prop!(nmg, 2, :el, &quot;elelemt_data&quot;) # add data to the 2nd node of nmg
true</code></pre><p>Finally notice that the data for the <code>flatgr</code> and the node inside <code>grv</code> are identical, meaning that they reference to the same part in memory.</p><pre><code class="language-julia-repl hljs">julia&gt; props(nmg.flatgr, 2) === props(nmg.grv[nmg.vmap[2][1]], nmg.vmap[2][2])
true</code></pre><p>As a result, updates to the modified data are done instantly.</p><p>The same holds for deeper nested graphs and for edge data.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>There are many <a href="https://stackoverflow.com/questions/38601141/what-is-the-difference-between-and-comparison-operators-in-julia">resources</a> online for the difference between <code>==</code> and <code>===</code> in Julia. </p></div></div><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p><code>NestedGraphs.jl</code> boils down to just being a wrapper. This means more graph types can be supported. Future efforts will focus on incorporating more popular graph types into this package.</p></div></div><h1 id="A-use-case-with-multi-layer-graphs"><a class="docs-heading-anchor" href="#A-use-case-with-multi-layer-graphs">A use case with multi layer graphs</a><a id="A-use-case-with-multi-layer-graphs-1"></a><a class="docs-heading-anchor-permalink" href="#A-use-case-with-multi-layer-graphs" title="Permalink"></a></h1><p><code>NestedGraphs</code> provides an interface to handle structures of interacting graph groups. A common use case might be dealing with multi layer graphs. You can create a multi layer graph with the syntax already provided:</p><pre><code class="language-julia-repl hljs">julia&gt; layer1 = complete_graph(4)
{4, 6} undirected simple Int64 graph

julia&gt; layer2 = barabasi_albert(4, 3; seed=123)
{4, 3} undirected simple Int64 graph

julia&gt; layer3 = SimpleGraph(3)
{3, 0} undirected simple Int64 graph

julia&gt; add_edge!(layer3, 1,2)
true

julia&gt; add_edge!(layer3, 2,3)
true

julia&gt; mlg = NestedGraph([layer1, layer2, layer3])  # now form the interlayer edges
NestedGraph{SimpleGraph{Int64},SimpleGraph{Int64}}({11,11}, 3 subgraphs)

julia&gt; for v in 1:(nv(layer2)-1)
           add_edge!(mlg, NestedEdge(1,v, 2,v))
       end

julia&gt; for v in 1:(nv(layer3)-1)
           add_edge!(mlg, NestedEdge(2,v, 3,v))
       end

julia&gt; add_edge!(mlg, NestedEdge(1,4, 3,3))
true</code></pre><p>Using <a href="https://github.com/UniStuttgart-IKR/NestedGraphMakie.jl">NestedGraphMakie.jl</a> you can visualize with <code>ngraphplot(mlg; multilayer=true, nlabels=repr.(mlg.vmap))</code>, which outputs:</p><p><img src="../assets/mlgraph.png" alt="Plot using NestedGraphMakie.jl"/></p><p>For more visualizations have a look in the <code>NestedGraphMakie.jl</code> repository.</p><p><code>NestedGraphs.jl</code> offers some helpful functions which can often be used for multi layer graphs. You can get the squashed graph by merging all multi layer nodes together using</p><pre><code class="language-julia-repl hljs">julia&gt; sg,vm = getmlsquashedgraph(mlg)
(SimpleGraph{Int64}(9, [[2, 3, 4, 5], [1, 3, 4, 5], [1, 2, 4, 5], [1, 2, 3], [1, 2, 3]]), [1, 2, 3, 4, 1, 2, 3, 5, 1, 2, 4])</code></pre><p><code>sg</code> is a simple graph, which if we plot we will get a graph like if all nodes were in the same layer. We plot using <code>GraphMakie.graphplot(sg)</code></p><p><img src="../assets/squashedgraph.png" alt="Plot using GraphMakie.jl"/></p><p>We can get all multi layer nodes groupped together with</p><pre><code class="language-julia-repl hljs">julia&gt; mlvertices = getmlvertices(mlg; subgraph_view=true)
5-element Vector{Vector{Tuple{Int64, Int64}}}:
 [(1, 1), (2, 1), (3, 1)]
 [(1, 2), (2, 2), (3, 2)]
 [(1, 3), (2, 3)]
 [(1, 4), (3, 3)]
 [(2, 4)]</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../API/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 13 June 2023 06:59">Tuesday 13 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
